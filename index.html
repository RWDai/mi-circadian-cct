<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ç±³æ™ºèƒ½å®¶å±…æå®¢ç‰ˆè‰²æ¸©æ›²çº¿ç”Ÿæˆå™¨</title>
    <link href="https://cdn.jsdelivr.net/npm/preline@2.0.3/dist/preline.min.css" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>tailwind.config = { darkMode: 'class' }</script>
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
</head>

<body class="bg-gray-50 dark:bg-neutral-900 min-h-screen">
    <div class="max-w-2xl mx-auto px-4 py-8">
        <header class="flex justify-between items-center mb-6">
            <h1 class="text-xl font-semibold text-gray-800 dark:text-white">æ˜¼å¤œèŠ‚å¾‹æ›²çº¿ç”Ÿæˆå™¨</h1>
            <button onclick="toggleTheme()"
                class="p-2 rounded-lg bg-white dark:bg-neutral-800 border border-gray-200 dark:border-neutral-700 hover:bg-gray-100 dark:hover:bg-neutral-700">
                <span id="themeIcon">ğŸŒ™</span>
            </button>
        </header>

        <!-- Tab åˆ‡æ¢ -->
        <div class="flex gap-2 mb-4">
            <button id="tabCCT" onclick="switchTab('cct')"
                class="flex-1 py-2.5 px-4 text-sm font-medium rounded-lg border transition-colors">
                è‰²æ¸©æ›²çº¿
            </button>
            <button id="tabBrightness" onclick="switchTab('brightness')"
                class="flex-1 py-2.5 px-4 text-sm font-medium rounded-lg border transition-colors">
                äº®åº¦æ›²çº¿
            </button>
        </div>

        <!-- è‰²æ¸©é¢æ¿ -->
        <div id="panelCCT">
            <!-- å‚æ•°è®¾ç½® -->
            <div
                class="bg-white dark:bg-neutral-800 border border-gray-200 dark:border-neutral-700 rounded-xl p-5 mb-4 shadow-sm">
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 dark:text-neutral-300 mb-1.5">
                            çº¬åº¦ <a href="https://cnbj1.fds.api.xiaomi.com/mijia-tob/prod/ai-config/pos-v2/index.html"
                                target="_blank" class="text-blue-600 hover:underline text-xs">(æŸ¥è¯¢)</a>
                        </label>
                        <input type="number" id="latitude" step="0.001" placeholder="å¦‚: 39.904"
                            class="py-2.5 px-3 block w-full border border-gray-200 dark:border-neutral-700 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500 dark:bg-neutral-900 dark:text-neutral-400">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 dark:text-neutral-300 mb-1.5">è¿‡æ¸¡é™¡åº¦
                            (k)</label>
                        <input type="number" id="steepness" value="5" step="0.5" min="1" max="20"
                            class="py-2.5 px-3 block w-full border border-gray-200 dark:border-neutral-700 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500 dark:bg-neutral-900 dark:text-neutral-400">
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 dark:text-neutral-300 mb-1.5">æœ€ä½è‰²æ¸©
                            (K)</label>
                        <input type="number" id="minTemp" value="2700"
                            class="py-2.5 px-3 block w-full border border-gray-200 dark:border-neutral-700 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500 dark:bg-neutral-900 dark:text-neutral-400">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 dark:text-neutral-300 mb-1.5">æœ€é«˜è‰²æ¸©
                            (K)</label>
                        <input type="number" id="maxTemp" value="6500"
                            class="py-2.5 px-3 block w-full border border-gray-200 dark:border-neutral-700 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500 dark:bg-neutral-900 dark:text-neutral-400">
                    </div>
                </div>
            </div>

            <!-- æ›²çº¿é¢„è§ˆ -->
            <div
                class="bg-white dark:bg-neutral-800 border border-gray-200 dark:border-neutral-700 rounded-xl p-5 mb-4 shadow-sm">
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-sm font-medium text-gray-800 dark:text-white">æ›²çº¿ç¼–è¾‘å™¨</h3>
                    <div class="flex gap-4 text-xs text-gray-500 dark:text-neutral-400">
                        <span>æ—¥å‡º: <b id="sunrise" class="text-gray-800 dark:text-white">--:--</b></span>
                        <span>æ—¥è½: <b id="sunset" class="text-gray-800 dark:text-white">--:--</b></span>
                    </div>
                </div>
                <p class="text-xs text-gray-400 dark:text-neutral-500 mb-2">ç‚¹å‡»æ·»åŠ å…³é”®å¸§ | æ‹–åŠ¨è°ƒæ•´ | åŒå‡»åˆ é™¤</p>
                <div class="bg-gray-50 dark:bg-neutral-900 rounded-lg p-2">
                    <canvas id="canvas" class="w-full rounded cursor-crosshair" style="height:180px"></canvas>
                </div>
            </div>

            <!-- å…³é”®å¸§åˆ—è¡¨ -->
            <div
                class="bg-white dark:bg-neutral-800 border border-gray-200 dark:border-neutral-700 rounded-xl p-5 mb-4 shadow-sm">
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-sm font-medium text-gray-800 dark:text-white">å…³é”®å¸§ <span
                            class="text-xs text-gray-400 font-normal">(å¯ç›´æ¥ç¼–è¾‘)</span></h3>
                    <div class="flex gap-3">
                        <button onclick="addKeyframe()" class="text-xs text-blue-600 hover:underline">+ æ·»åŠ </button>
                        <button onclick="resetKeyframes()" class="text-xs text-gray-500 hover:underline">é‡ç½®</button>
                    </div>
                </div>
                <div id="keyframeList" class="space-y-2 max-h-48 overflow-y-auto"></div>
            </div>

            <!-- å…¬å¼è¾“å‡º -->
            <div
                class="bg-white dark:bg-neutral-800 border border-gray-200 dark:border-neutral-700 rounded-xl p-5 shadow-sm">
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-sm font-medium text-gray-800 dark:text-white">ç±³å®¶æå®¢ç‰ˆå…¬å¼</h3>
                    <button onclick="copyFormula()"
                        class="py-1.5 px-3 text-xs font-medium rounded-lg border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-800 text-gray-800 dark:text-white hover:bg-gray-50 dark:hover:bg-neutral-700">å¤åˆ¶</button>
                </div>
                <div id="formula"
                    class="p-3 bg-gray-50 dark:bg-neutral-900 rounded-lg font-mono text-xs text-gray-600 dark:text-neutral-400 whitespace-pre-wrap break-all max-h-36 overflow-y-auto select-all">
                </div>
                <p id="formulaLen" class="text-xs text-gray-400 mt-2"></p>
                <div class="mt-3 p-3 bg-gray-100 dark:bg-neutral-700 rounded-lg overflow-x-auto">
                    <p class="text-xs text-gray-500 dark:text-neutral-400 mb-2">æ•°å­¦è¡¨è¾¾å¼ (LaTeX):</p>
                    <div id="formulaMath" class="text-sm"></div>
                </div>
            </div>
        </div>

        <!-- äº®åº¦é¢æ¿ -->
        <div id="panelBrightness" class="hidden">
            <!-- å‚æ•°è®¾ç½® -->
            <div
                class="bg-white dark:bg-neutral-800 border border-gray-200 dark:border-neutral-700 rounded-xl p-5 mb-4 shadow-sm">
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 dark:text-neutral-300 mb-1.5">
                            çº¬åº¦ <a href="https://cnbj1.fds.api.xiaomi.com/mijia-tob/prod/ai-config/pos-v2/index.html"
                                target="_blank" class="text-blue-600 hover:underline text-xs">(æŸ¥è¯¢)</a>
                        </label>
                        <input type="number" id="latitudeBri" step="0.001" placeholder="å¦‚: 39.904"
                            class="py-2.5 px-3 block w-full border border-gray-200 dark:border-neutral-700 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500 dark:bg-neutral-900 dark:text-neutral-400">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 dark:text-neutral-300 mb-1.5">è¿‡æ¸¡é™¡åº¦
                            (k)</label>
                        <input type="number" id="steepnessBri" value="5" step="0.5" min="1" max="20"
                            class="py-2.5 px-3 block w-full border border-gray-200 dark:border-neutral-700 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500 dark:bg-neutral-900 dark:text-neutral-400">
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 dark:text-neutral-300 mb-1.5">æœ€ä½äº®åº¦
                            (%)</label>
                        <input type="number" id="minBri" value="1" min="0" max="99"
                            class="py-2.5 px-3 block w-full border border-gray-200 dark:border-neutral-700 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500 dark:bg-neutral-900 dark:text-neutral-400">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 dark:text-neutral-300 mb-1.5">æœ€é«˜äº®åº¦
                            (%)</label>
                        <input type="number" id="maxBri" value="100" disabled
                            class="py-2.5 px-3 block w-full border border-gray-200 dark:border-neutral-700 rounded-lg text-sm bg-gray-100 dark:bg-neutral-700 dark:text-neutral-500 cursor-not-allowed">
                    </div>
                </div>
            </div>

            <!-- æ›²çº¿é¢„è§ˆ -->
            <div
                class="bg-white dark:bg-neutral-800 border border-gray-200 dark:border-neutral-700 rounded-xl p-5 mb-4 shadow-sm">
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-sm font-medium text-gray-800 dark:text-white">æ›²çº¿ç¼–è¾‘å™¨</h3>
                    <div class="flex flex-wrap gap-x-4 gap-y-1 text-xs text-gray-500 dark:text-neutral-400">
                        <span title="æ°‘ç”¨æ›™å…‰å¼€å§‹ï¼ˆå¤ªé˜³-6Â°ï¼‰">æ›™å…‰: <b id="civilDawnBri" class="text-amber-600">--:--</b></span>
                        <span title="æ—¥å‡ºï¼ˆå¤ªé˜³ä¸Šè¾¹ç¼˜è§¦åŠåœ°å¹³çº¿ï¼‰">æ—¥å‡º: <b id="sunriseBri" class="text-orange-500">--:--</b></span>
                        <span title="æ—¥è½ï¼ˆå¤ªé˜³ä¸‹è¾¹ç¼˜è§¦åŠåœ°å¹³çº¿ï¼‰">æ—¥è½: <b id="sunsetBri" class="text-orange-500">--:--</b></span>
                        <span title="æ°‘ç”¨æš®å…‰ç»“æŸï¼ˆå¤ªé˜³-6Â°ï¼‰">æš®å…‰: <b id="civilDuskBri" class="text-amber-600">--:--</b></span>
                    </div>
                </div>
                <p class="text-xs text-gray-400 dark:text-neutral-500 mb-2">ç‚¹å‡»æ·»åŠ å…³é”®å¸§ | æ‹–åŠ¨è°ƒæ•´ | åŒå‡»åˆ é™¤</p>
                <div class="bg-gray-50 dark:bg-neutral-900 rounded-lg p-2">
                    <canvas id="canvasBri" class="w-full rounded cursor-crosshair" style="height:180px"></canvas>
                </div>
            </div>

            <!-- å…³é”®å¸§åˆ—è¡¨ -->
            <div
                class="bg-white dark:bg-neutral-800 border border-gray-200 dark:border-neutral-700 rounded-xl p-5 mb-4 shadow-sm">
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-sm font-medium text-gray-800 dark:text-white">å…³é”®å¸§ <span
                            class="text-xs text-gray-400 font-normal">(å¯ç›´æ¥ç¼–è¾‘)</span></h3>
                    <div class="flex gap-3">
                        <button onclick="addKeyframeBri()" class="text-xs text-blue-600 hover:underline">+ æ·»åŠ </button>
                        <button onclick="resetKeyframesBri()" class="text-xs text-gray-500 hover:underline">é‡ç½®</button>
                    </div>
                </div>
                <div id="keyframeListBri" class="space-y-2 max-h-48 overflow-y-auto"></div>
            </div>

            <!-- å…¬å¼è¾“å‡º -->
            <div
                class="bg-white dark:bg-neutral-800 border border-gray-200 dark:border-neutral-700 rounded-xl p-5 shadow-sm">
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-sm font-medium text-gray-800 dark:text-white">ç±³å®¶æå®¢ç‰ˆå…¬å¼</h3>
                    <button onclick="copyFormulaBri()"
                        class="py-1.5 px-3 text-xs font-medium rounded-lg border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-800 text-gray-800 dark:text-white hover:bg-gray-50 dark:hover:bg-neutral-700">å¤åˆ¶</button>
                </div>
                <div id="formulaBri"
                    class="p-3 bg-gray-50 dark:bg-neutral-900 rounded-lg font-mono text-xs text-gray-600 dark:text-neutral-400 whitespace-pre-wrap break-all max-h-36 overflow-y-auto select-all">
                </div>
                <p id="formulaLenBri" class="text-xs text-gray-400 mt-2"></p>
                <div class="mt-3 p-3 bg-gray-100 dark:bg-neutral-700 rounded-lg overflow-x-auto">
                    <p class="text-xs text-gray-500 dark:text-neutral-400 mb-2">æ•°å­¦è¡¨è¾¾å¼ (LaTeX):</p>
                    <div id="formulaMathBri" class="text-sm"></div>
                </div>
            </div>
        </div>

        <footer class="text-center mt-6 text-xs text-gray-400 dark:text-neutral-500">
            æ‰€æœ‰è®¡ç®—åœ¨æœ¬åœ°å®Œæˆ Â· <a href="https://github.com/RWDai/mi-circadian-cct"
                class="text-blue-600 hover:underline">GitHub</a>
        </footer>
    </div>

    <script>
        // ä¸»é¢˜
        if (localStorage.theme === 'dark') document.documentElement.classList.add('dark'), document.getElementById('themeIcon').textContent = 'â˜€ï¸';
        function toggleTheme() {
            const d = document.documentElement.classList.toggle('dark');
            document.getElementById('themeIcon').textContent = d ? 'â˜€ï¸' : 'ğŸŒ™';
            localStorage.theme = d ? 'dark' : '';
            draw();
            drawBri();
        }

        // å½“å‰ Tab
        let currentTab = 'cct';
        function switchTab(tab) {
            currentTab = tab;
            const dark = document.documentElement.classList.contains('dark');
            document.getElementById('panelCCT').classList.toggle('hidden', tab !== 'cct');
            document.getElementById('panelBrightness').classList.toggle('hidden', tab !== 'brightness');
            // Tab æŒ‰é’®æ ·å¼
            const activeClass = dark ? 'bg-blue-600 border-blue-600 text-white' : 'bg-blue-600 border-blue-600 text-white';
            const inactiveClass = dark ? 'bg-neutral-800 border-neutral-700 text-neutral-400 hover:bg-neutral-700' : 'bg-white border-gray-200 text-gray-600 hover:bg-gray-50';
            document.getElementById('tabCCT').className = `flex-1 py-2.5 px-4 text-sm font-medium rounded-lg border transition-colors ${tab === 'cct' ? activeClass : inactiveClass}`;
            document.getElementById('tabBrightness').className = `flex-1 py-2.5 px-4 text-sm font-medium rounded-lg border transition-colors ${tab === 'brightness' ? activeClass : inactiveClass}`;
            if (tab === 'brightness') {
                initCanvasBri();
                drawBri();
            } else {
                initCanvas();
                draw();
            }
        }

        // çŠ¶æ€ - è‰²æ¸©
        let keyframes = [], dragging = -1, canvas, ctx;
        // çŠ¶æ€ - äº®åº¦
        let keyframesBri = [], draggingBri = -1, canvasBri, ctxBri;
        const getVal = id => parseFloat(document.getElementById(id).value) || 0;

        // å…³é”®å¸§ç±»å‹è¾…åŠ©å‡½æ•°
        function resolveKeyframeTime(kf, sunTimes) {
            if (kf.type === 'fixed') return kf.t;
            const offset = kf.offset || 0;
            const times = {
                sunrise: sunTimes.sun?.rise || 6,
                sunset: sunTimes.sun?.set || 18,
                civil_dawn: sunTimes.civil?.rise || 5.5,
                civil_dusk: sunTimes.civil?.set || 18.5
            };
            return Math.max(0, Math.min(24, times[kf.type] + offset));
        }

        function getKeyframeColor(type) {
            return {
                fixed: '#3b82f6',
                sunrise: '#f59e0b',
                sunset: '#f59e0b',
                civil_dawn: '#fbbf24',
                civil_dusk: '#fbbf24'
            }[type] || '#3b82f6';
        }

        function formatOffset(hours) {
            if (!hours) return '';
            const sign = hours > 0 ? '+' : '';
            const h = Math.floor(Math.abs(hours));
            const m = Math.round((Math.abs(hours) % 1) * 60);
            if (h === 0) return `${sign}${m}min`;
            if (m === 0) return `${sign}${h}h`;
            return `${sign}${h}h${m}min`;
        }

        // æ—¥å‡ºæ—¥è½è®¡ç®—ï¼ˆæ”¯æŒä¸åŒå¤ªé˜³é«˜åº¦è§’ï¼‰
        function calcSun(lat, angle = -0.833) {
            const day = Math.floor((new Date() - new Date(new Date().getFullYear(), 0, 0)) / 864e5);
            const r = lat * Math.PI / 180;
            const d = 23.44 * Math.sin(2 * Math.PI * (day - 81) / 365) * Math.PI / 180;
            const a = angle * Math.PI / 180;
            const cosH = (Math.sin(a) - Math.sin(r) * Math.sin(d)) / (Math.cos(r) * Math.cos(d));
            if (cosH < -1 || cosH > 1) return null; // ææ˜¼æˆ–æå¤œ
            const h = Math.acos(cosH) * 180 / Math.PI / 15;
            return { rise: 12 - h, set: 12 + h };
        }

        // è·å–å®Œæ•´çš„å¤ªé˜³æ—¶é—´ï¼ˆæ—¥å‡ºæ—¥è½ + æ›™æš®å…‰ï¼‰
        function getSunTimes(lat) {
            return {
                sun: calcSun(lat, -0.833),      // æ—¥å‡ºæ—¥è½ï¼ˆè€ƒè™‘å¤§æ°”æŠ˜å°„ï¼‰
                civil: calcSun(lat, -6),        // æ°‘ç”¨æ›™æš®å…‰
                nautical: calcSun(lat, -12),    // èˆªæµ·æ›™æš®å…‰
                astro: calcSun(lat, -18)        // å¤©æ–‡æ›™æš®å…‰
            };
        }

        function fmt(h) { return `${Math.floor(h).toString().padStart(2, '0')}:${Math.floor((h % 1) * 60).toString().padStart(2, '0')}`; }

        // ç”ŸæˆåŠ¨æ€æ—¥å‡ºæ—¥è½æ—¶é—´å…¬å¼ï¼ˆç±³å®¶æå®¢ç‰ˆï¼‰
        function generateDynamicSunTime(lat, angle, isRise, offset = 0) {
            const latRad = lat * Math.PI / 180;
            const sinLat = Math.sin(latRad).toFixed(4);
            const cosLat = Math.cos(latRad).toFixed(4);
            const sinAngle = Math.sin(angle * Math.PI / 180).toFixed(5);
            const declCoef = (23.44 * Math.PI / 180).toFixed(4);
            const dayCoef = (2 * Math.PI / 365).toFixed(4);
            const hourCoef = (180 / Math.PI / 15).toFixed(2);

            const day = `((month()-1)*30.5+date())`;
            const decl = `(${declCoef}*sin(${dayCoef}*(${day}-81)))`;
            const cosH = `((${sinAngle}-${sinLat}*sin(${decl}))/(${cosLat}*cos(${decl})))`;
            const H = `(acos(${cosH})*${hourCoef})`;
            const time = isRise ? `(12-${H})` : `(12+${H})`;
            const offsetHours = offset ? `+${offset}` : '';
            return `((${time}${offsetHours})*3600)`;
        }

        // è·å–å…³é”®å¸§æ—¶é—´è¡¨è¾¾å¼ï¼ˆå›ºå®šæˆ–åŠ¨æ€ï¼‰
        function getTimeExpression(kf, lat) {
            if (kf.type === 'fixed') {
                return Math.round(kf.t * 3600);
            }
            const angleMap = {
                sunrise: -0.833, sunset: -0.833,
                civil_dawn: -6, civil_dusk: -6
            };
            const isRise = kf.type === 'sunrise' || kf.type === 'civil_dawn';
            return generateDynamicSunTime(lat, angleMap[kf.type], isRise, kf.offset || 0);
        }

        // Canvas
        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = canvas.offsetHeight * 2;
            ctx.scale(2, 2);
            canvas.onmousedown = e => {
                const p = getPos(e), i = findKF(p);
                if (i >= 0) dragging = i;
                else { keyframes.push({ t: p.x / canvas.offsetWidth * 24, v: 1 - p.y / canvas.offsetHeight }); keyframes.sort((a, b) => a.t - b.t); update(); }
                draw();
            };
            canvas.onmousemove = e => {
                if (dragging < 0) return;
                const p = getPos(e), minT = getVal('minTemp'), maxT = getVal('maxTemp');
                keyframes[dragging].t = Math.max(0, Math.min(24, p.x / canvas.offsetWidth * 24));
                keyframes[dragging].v = Math.max(0, Math.min(1, 1 - p.y / canvas.offsetHeight));
                keyframes.sort((a, b) => a.t - b.t);
                dragging = keyframes.findIndex(k => k === keyframes.find(x => x.t === keyframes[dragging]?.t));
                draw(); update();
            };
            canvas.onmouseup = canvas.onmouseleave = () => dragging = -1;
            canvas.ondblclick = e => {
                const i = findKF(getPos(e));
                if (i >= 0 && keyframes.length > 2) { keyframes.splice(i, 1); draw(); update(); }
            };
        }

        function getPos(e) { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
        function findKF(p) {
            const w = canvas.offsetWidth, h = canvas.offsetHeight;
            const lat = getVal('latitude');
            const sunTimes = lat ? getSunTimes(lat) : null;
            for (let i = 0; i < keyframes.length; i++) {
                const t = sunTimes ? resolveKeyframeTime(keyframes[i], sunTimes) : (keyframes[i].t || 0);
                const kx = t / 24 * w, ky = (1 - keyframes[i].v) * h;
                if (Math.hypot(kx - p.x, ky - p.y) < 10) return i;
            }
            return -1;
        }

        // Sigmoid æ’å€¼ (æ”¯æŒ24å°æ—¶å¾ªç¯)
        function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }
        function getEffectiveKeyframes() {
            if (keyframes.length < 2) return keyframes;
            const lat = getVal('latitude');
            const sunTimes = lat ? getSunTimes(lat) : null;
            const resolved = keyframes.map(kf => ({
                t: sunTimes ? resolveKeyframeTime(kf, sunTimes) : (kf.t || 0),
                v: kf.v
            }));
            const first = resolved[0];
            const last = resolved[resolved.length - 1];
            resolved.unshift({ t: last.t - 24, v: last.v });
            resolved.push({ t: first.t + 24, v: first.v });
            return resolved;
        }
        // ä½¿ç”¨ sigmoid å åŠ æ–¹å¼æ’å€¼ï¼ˆä¸å…¬å¼ä¸€è‡´ï¼‰
        function interpolate(t) {
            if (keyframes.length < 2) return 0.5;
            const kf = getEffectiveKeyframes();
            const k = getVal('steepness');

            // èµ·å§‹å€¼
            let value = kf[0].v;

            // å åŠ æ¯ä¸ªè¿‡æ¸¡çš„ sigmoid
            for (let i = 0; i < kf.length - 1; i++) {
                const t1 = kf[i].t;
                const t2 = kf[i + 1].t;
                const delta = kf[i + 1].v - kf[i].v;
                if (delta !== 0) {
                    const mid = (t1 + t2) / 2;
                    const width = Math.max(0.001, (t2 - t1) / 2);
                    const x = k * (t - mid) / width;
                    value += delta * sigmoid(x);
                }
            }
            return Math.max(0, Math.min(1, value));
        }

        // Yè½´ç•™ç™½æ¯”ä¾‹
        const yPadding = 0.1;
        const yAxisExpand = 0.25; // Yè½´èŒƒå›´æ‰©å±•æ¯”ä¾‹
        function vToY(v, h) { return h * (yPadding + (1 - v) * (1 - 2 * yPadding)); }
        function yToV(y, h) { return 1 - (y / h - yPadding) / (1 - 2 * yPadding); }
        function getYAxisRange(minT, maxT) {
            // Yè½´èŒƒå›´æ¯”å®é™…è‰²æ¸©èŒƒå›´ç¨å¤§
            const range = maxT - minT;
            const expand = range * yAxisExpand;
            return { min: Math.round(minT - expand), max: Math.round(maxT + expand) };
        }

        // ç»˜åˆ¶
        function draw() {
            if (!ctx) return;
            const w = canvas.offsetWidth, h = canvas.offsetHeight, lat = getVal('latitude');
            const minT = getVal('minTemp'), maxT = getVal('maxTemp');
            const dark = document.documentElement.classList.contains('dark');
            ctx.clearRect(0, 0, w, h);

            // ç½‘æ ¼
            ctx.strokeStyle = dark ? '#374151' : '#e5e7eb';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 24; i += 6) {
                const x = i / 24 * w;
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
                ctx.fillStyle = '#9ca3af'; ctx.font = '10px sans-serif';
                ctx.fillText(`${i}:00`, x + 2, h - 4);
            }
            const yRange = getYAxisRange(minT, maxT);

            // Yè½´ç½‘æ ¼çº¿ï¼ˆæŒ‰1000Ké—´éš”ï¼‰
            ctx.strokeStyle = dark ? '#374151' : '#e5e7eb';
            ctx.setLineDash([]);
            ctx.lineWidth = 1;
            // è®¡ç®—Yè½´åˆ»åº¦èŒƒå›´ï¼ˆæŒ‰1000å–æ•´ï¼‰
            const yStart = Math.ceil(yRange.min / 1000) * 1000;
            const yEnd = Math.floor(yRange.max / 1000) * 1000;
            for (let temp = yStart; temp <= yEnd; temp += 1000) {
                // å°†æ¸©åº¦å€¼è½¬æ¢ä¸ºvå€¼ï¼ˆ0-1èŒƒå›´å¯èƒ½è¶…å‡ºï¼‰
                const v = (temp - minT) / (maxT - minT);
                const y = vToY(v, h);
                // åªç»˜åˆ¶åœ¨ç”»å¸ƒèŒƒå›´å†…çš„çº¿
                if (y >= 0 && y <= h) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                    ctx.fillStyle = '#9ca3af'; ctx.font = '10px sans-serif';
                    ctx.fillText(`${temp}K`, 4, y - 4);
                }
            }

            // Yè½´ä¸Šä¸‹è¾¹ç•Œçº¿
            ctx.strokeStyle = dark ? '#4b5563' : '#d1d5db';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(w, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, h); ctx.lineTo(w, h); ctx.stroke();

            // æœ€ä½/æœ€é«˜è‰²æ¸©å‚è€ƒçº¿ï¼ˆè™šçº¿ï¼Œçªå‡ºæ˜¾ç¤ºï¼‰
            ctx.strokeStyle = dark ? '#9ca3af' : '#6b7280';
            ctx.setLineDash([4, 4]);
            ctx.lineWidth = 1;
            // æœ€é«˜è‰²æ¸©çº¿ (v=1)
            const yMax = vToY(1, h);
            ctx.beginPath(); ctx.moveTo(0, yMax); ctx.lineTo(w, yMax); ctx.stroke();
            ctx.fillStyle = dark ? '#d1d5db' : '#4b5563';
            ctx.fillText(`â† ${maxT}K (æœ€é«˜)`, w - 80, yMax + 12);
            // æœ€ä½è‰²æ¸©çº¿ (v=0)
            const yMin = vToY(0, h);
            ctx.beginPath(); ctx.moveTo(0, yMin); ctx.lineTo(w, yMin); ctx.stroke();
            ctx.fillText(`â† ${minT}K (æœ€ä½)`, w - 80, yMin - 4);
            ctx.setLineDash([]);

            // æ—¥å‡ºæ—¥è½çº¿
            if (lat) {
                const sun = calcSun(lat);
                document.getElementById('sunrise').textContent = fmt(sun.rise);
                document.getElementById('sunset').textContent = fmt(sun.set);
                ctx.strokeStyle = '#f59e0b'; ctx.setLineDash([4, 4]);
                [sun.rise, sun.set].forEach(t => {
                    const x = t / 24 * w;
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
                });
                ctx.setLineDash([]);
            } else {
                document.getElementById('sunrise').textContent = '--:--';
                document.getElementById('sunset').textContent = '--:--';
            }

            // æ›²çº¿
            ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2;
            ctx.beginPath();
            for (let t = 0; t <= 24; t += 0.05) {
                const x = t / 24 * w, y = vToY(interpolate(t), h);
                t === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.stroke();

            // å…³é”®å¸§ç‚¹
            const sunTimes = lat ? getSunTimes(lat) : null;
            keyframes.forEach((kf, i) => {
                const t = sunTimes ? resolveKeyframeTime(kf, sunTimes) : (kf.t || 0);
                ctx.beginPath();
                ctx.arc(t / 24 * w, vToY(kf.v, h), 7, 0, Math.PI * 2);
                ctx.fillStyle = i === dragging ? '#ef4444' : getKeyframeColor(kf.type || 'fixed');
                ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
            });
        }

        // æ›´æ–°å…³é”®å¸§åˆ—è¡¨å’Œå…¬å¼
        function update() {
            const minT = getVal('minTemp'), maxT = getVal('maxTemp');
            const lat = getVal('latitude');
            const sunTimes = lat ? getSunTimes(lat) : null;
            const list = document.getElementById('keyframeList');
            list.innerHTML = keyframes.map((kf, i) => {
                const temp = Math.round(minT + kf.v * (maxT - minT));
                const type = kf.type || 'fixed';
                const resolvedTime = sunTimes ? resolveKeyframeTime(kf, sunTimes) : (kf.t || 0);
                const h = Math.floor(type === 'fixed' ? (kf.t || 0) : resolvedTime);
                const m = Math.floor((type === 'fixed' ? (kf.t || 0) : resolvedTime) % 1 * 60);
                const offsetH = Math.floor(Math.abs(kf.offset || 0));
                const offsetM = Math.round((Math.abs(kf.offset || 0) % 1) * 60);
                const offsetSign = (kf.offset || 0) >= 0 ? '+' : '-';

                return `<div class="flex items-center gap-2 text-xs py-1.5 px-2 bg-gray-50 dark:bg-neutral-900 rounded">
                    <select onchange="updateKF(${i},'type',this.value)" class="px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white" style="font-size:10px">
                        <option value="fixed" ${type === 'fixed' ? 'selected' : ''}>å›ºå®š</option>
                        <option value="sunrise" ${type === 'sunrise' ? 'selected' : ''}>æ—¥å‡º</option>
                        <option value="sunset" ${type === 'sunset' ? 'selected' : ''}>æ—¥è½</option>
                        <option value="civil_dawn" ${type === 'civil_dawn' ? 'selected' : ''}>æ›™å…‰</option>
                        <option value="civil_dusk" ${type === 'civil_dusk' ? 'selected' : ''}>æš®å…‰</option>
                    </select>
                    ${type === 'fixed' ? `
                        <input type="number" value="${h}" min="0" max="23" onchange="updateKF(${i},'h',this.value)" class="w-12 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                        <span class="text-gray-400">:</span>
                        <input type="number" value="${m}" min="0" max="59" step="5" onchange="updateKF(${i},'m',this.value)" class="w-12 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                    ` : `
                        <select onchange="updateKF(${i},'offsetSign',this.value)" class="w-8 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                            <option value="+" ${offsetSign === '+' ? 'selected' : ''}>+</option>
                            <option value="-" ${offsetSign === '-' ? 'selected' : ''}>-</option>
                        </select>
                        <input type="number" value="${offsetH}" min="0" max="5" onchange="updateKF(${i},'offsetH',this.value)" class="w-10 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                        <span class="text-gray-400">h</span>
                        <input type="number" value="${offsetM}" min="0" max="59" step="5" onchange="updateKF(${i},'offsetM',this.value)" class="w-10 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                        <span class="text-gray-400">m</span>
                        <span class="text-gray-400" style="font-size:9px">(${fmt(resolvedTime)})</span>
                    `}
                    <span class="text-gray-400 mx-1">â†’</span>
                    <input type="number" value="${temp}" min="${minT}" max="${maxT}" step="100" onchange="updateKF(${i},'temp',this.value)" class="w-16 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                    <span class="text-gray-500">K</span>
                    ${keyframes.length > 2 ? `<button onclick="deleteKF(${i})" class="ml-auto text-red-500 hover:text-red-700">Ã—</button>` : ''}
                </div>`;
            }).join('');
            generateFormula();
        }

        function updateKF(i, field, val) {
            const minT = getVal('minTemp'), maxT = getVal('maxTemp');
            const kf = keyframes[i];
            if (field === 'type') {
                kf.type = val;
                if (val === 'fixed') {
                    kf.t = kf.t || 12;
                    delete kf.offset;
                } else {
                    kf.offset = kf.offset || 0;
                    delete kf.t;
                }
            } else if (field === 'h') {
                const m = ((kf.t || 0) % 1) * 60;
                kf.t = Math.max(0, Math.min(24, parseInt(val) + m / 60));
            } else if (field === 'm') {
                const h = Math.floor(kf.t || 0);
                kf.t = Math.max(0, Math.min(24, h + parseInt(val) / 60));
            } else if (field === 'offsetSign') {
                kf.offset = (val === '+' ? 1 : -1) * Math.abs(kf.offset || 0);
            } else if (field === 'offsetH') {
                const sign = (kf.offset || 0) >= 0 ? 1 : -1;
                const m = (Math.abs(kf.offset || 0) % 1) * 60;
                kf.offset = sign * (parseInt(val) + m / 60);
            } else if (field === 'offsetM') {
                const sign = (kf.offset || 0) >= 0 ? 1 : -1;
                const h = Math.floor(Math.abs(kf.offset || 0));
                kf.offset = sign * (h + parseInt(val) / 60);
            } else if (field === 'temp') {
                kf.v = (parseInt(val) - minT) / (maxT - minT);
            }
            const lat = getVal('latitude');
            const sunTimes = lat ? getSunTimes(lat) : null;
            keyframes.sort((a, b) => {
                const ta = sunTimes ? resolveKeyframeTime(a, sunTimes) : (a.t || 0);
                const tb = sunTimes ? resolveKeyframeTime(b, sunTimes) : (b.t || 0);
                return ta - tb;
            });
            draw(); update();
        }

        function deleteKF(i) {
            if (keyframes.length > 2) { keyframes.splice(i, 1); draw(); update(); }
        }

        function addKeyframe() {
            keyframes.push({ type: 'fixed', t: 12, v: 0.5 });
            const lat = getVal('latitude');
            const sunTimes = lat ? getSunTimes(lat) : null;
            keyframes.sort((a, b) => {
                const ta = sunTimes ? resolveKeyframeTime(a, sunTimes) : (a.t || 0);
                const tb = sunTimes ? resolveKeyframeTime(b, sunTimes) : (b.t || 0);
                return ta - tb;
            });
            draw(); update();
        }

        // ç”Ÿæˆå…¬å¼ï¼ˆä½¿ç”¨ sigmoid å åŠ ï¼Œæ— æ¯”è¾ƒç¬¦å·ï¼‰
        function generateFormula() {
            const lat = getVal('latitude'), k = getVal('steepness');
            const minT = getVal('minTemp'), maxT = getVal('maxTemp');
            if (!lat || keyframes.length < 2) {
                document.getElementById('formula').textContent = 'è¯·è¾“å…¥çº¬åº¦å¹¶ç¡®ä¿è‡³å°‘æœ‰2ä¸ªå…³é”®å¸§';
                document.getElementById('formulaLen').textContent = '';
                document.getElementById('formulaMath').textContent = '';
                return;
            }

            // è§£æå…³é”®å¸§æ—¶é—´ï¼ˆç”¨äºé¢„è§ˆå’Œæ•°å­¦è¡¨è¾¾å¼ï¼‰
            const sunTimes = getSunTimes(lat);
            const resolved = keyframes.map(kf => ({
                t: resolveKeyframeTime(kf, sunTimes),
                v: kf.v
            })).sort((a, b) => a.t - b.t);

            // æ’åºåçš„åŸå§‹å…³é”®å¸§ï¼ˆç”¨äºç”ŸæˆåŠ¨æ€å…¬å¼ï¼‰
            const sortedKf = [...keyframes].sort((a, b) => {
                const ta = resolveKeyframeTime(a, sunTimes);
                const tb = resolveKeyframeTime(b, sunTimes);
                return ta - tb;
            });

            const time = '(hours()*3600+minutes()*60+seconds())';

            // èµ·å§‹å€¼
            const v0 = Math.round(minT + resolved[0].v * (maxT - minT));
            const parts = [`${v0}`];
            const mathParts = [`${v0}`];

            // å åŠ æ¯ä¸ªè¿‡æ¸¡çš„ sigmoid
            for (let i = 0; i < resolved.length - 1; i++) {
                const t1Expr = getTimeExpression(sortedKf[i], lat);
                const t2Expr = getTimeExpression(sortedKf[i + 1], lat);
                const t1 = Math.round(resolved[i].t * 3600);
                const t2 = Math.round(resolved[i + 1].t * 3600);
                const v1 = Math.round(minT + resolved[i].v * (maxT - minT));
                const v2 = Math.round(minT + resolved[i + 1].v * (maxT - minT));
                const midExpr = typeof t1Expr === 'number' && typeof t2Expr === 'number'
                    ? Math.round((t1Expr + t2Expr) / 2)
                    : `((${t1Expr}+${t2Expr})/2)`;
                const widthExpr = typeof t1Expr === 'number' && typeof t2Expr === 'number'
                    ? Math.max(1, Math.round((t2Expr - t1Expr) / 2))
                    : `((${t2Expr}-${t1Expr})/2)`;
                const delta = v2 - v1;

                if (delta !== 0) {
                    parts.push(`${delta}/(1+pow(e(),-${k}*(${time}-${midExpr})/${widthExpr}))`);
                    mathParts.push(`${delta} Ã— Ïƒ(${k}Ã—(t-${fmt(t1 / 3600 + (t2 - t1) / 7200)})/${Math.round((t2 - t1) / 120)}min)`);
                }
            }

            const formula = `floor(${parts.join('+')})`;
            document.getElementById('formula').textContent = formula;
            document.getElementById('formulaLen').textContent = `å…¬å¼é•¿åº¦: ${formula.length} å­—ç¬¦`;

            // æ•°å­¦è¡¨è¾¾å¼å±•ç¤ºï¼ˆKaTeX LaTeX é£æ ¼ï¼‰
            const mathTerms = [];
            for (let i = 0; i < resolved.length - 1; i++) {
                const t1 = Math.round(resolved[i].t * 3600);
                const t2 = Math.round(resolved[i + 1].t * 3600);
                const v1 = Math.round(minT + resolved[i].v * (maxT - minT));
                const v2 = Math.round(minT + resolved[i + 1].v * (maxT - minT));
                const mid = Math.round((t1 + t2) / 2);
                const width = Math.max(1, Math.round((t2 - t1) / 2));
                const delta = v2 - v1;
                if (delta !== 0) {
                    const sign = delta > 0 ? '+' : '';
                    mathTerms.push(`${sign}\\frac{${delta}}{1+e^{-${k} \\cdot \\frac{t-${mid}}{${width}}}}`);
                }
            }
            const latex = `\\left\\lfloor ${v0}${mathTerms.join('')} \\right\\rfloor`;
            const mathEl = document.getElementById('formulaMath');
            if (typeof katex !== 'undefined') {
                katex.render(latex, mathEl, { throwOnError: false, displayMode: true });
            } else {
                mathEl.textContent = latex;
            }
        }

        function copyFormula() {
            const f = document.getElementById('formula').textContent;
            if (f && !f.includes('è¯·')) navigator.clipboard.writeText(f).then(() => alert('å·²å¤åˆ¶'));
        }

        function resetKeyframes() {
            const lat = getVal('latitude');
            if (lat) {
                keyframes = [
                    { type: 'fixed', t: 0, v: 0 },
                    { type: 'sunrise', offset: 0, v: 0 },
                    { type: 'sunrise', offset: 1, v: 1 },
                    { type: 'sunset', offset: -1, v: 1 },
                    { type: 'sunset', offset: 0, v: 0 },
                    { type: 'fixed', t: 24, v: 0 }
                ];
            } else {
                keyframes = [{ type: 'fixed', t: 0, v: 0 }, { type: 'fixed', t: 12, v: 1 }];
            }
            draw(); update();
        }

        // åˆå§‹åŒ–
        window.onload = () => {
            initCanvas();
            resetKeyframes();
            initCanvasBri();
            resetKeyframesBri();
            switchTab('cct');
            ['latitude', 'steepness', 'minTemp', 'maxTemp'].forEach(id =>
                document.getElementById(id).addEventListener('input', () => { draw(); update(); })
            );
            ['latitudeBri', 'steepnessBri', 'minBri'].forEach(id =>
                document.getElementById(id).addEventListener('input', () => { drawBri(); updateBri(); })
            );
        };
        window.onresize = () => {
            initCanvas(); draw();
            if (!document.getElementById('panelBrightness').classList.contains('hidden')) {
                initCanvasBri(); drawBri();
            }
        };

        // ========== äº®åº¦æ›²çº¿åŠŸèƒ½ ==========
        function initCanvasBri() {
            canvasBri = document.getElementById('canvasBri');
            if (!canvasBri) return;
            ctxBri = canvasBri.getContext('2d');
            canvasBri.width = canvasBri.offsetWidth * 2;
            canvasBri.height = canvasBri.offsetHeight * 2;
            ctxBri.scale(2, 2);
            canvasBri.onmousedown = e => {
                const p = getPosBri(e), i = findKFBri(p);
                if (i >= 0) draggingBri = i;
                else { keyframesBri.push({ t: p.x / canvasBri.offsetWidth * 24, v: 1 - p.y / canvasBri.offsetHeight }); keyframesBri.sort((a, b) => a.t - b.t); updateBri(); }
                drawBri();
            };
            canvasBri.onmousemove = e => {
                if (draggingBri < 0) return;
                const p = getPosBri(e);
                keyframesBri[draggingBri].t = Math.max(0, Math.min(24, p.x / canvasBri.offsetWidth * 24));
                keyframesBri[draggingBri].v = Math.max(0, Math.min(1, 1 - p.y / canvasBri.offsetHeight));
                keyframesBri.sort((a, b) => a.t - b.t);
                drawBri(); updateBri();
            };
            canvasBri.onmouseup = canvasBri.onmouseleave = () => draggingBri = -1;
            canvasBri.ondblclick = e => {
                const i = findKFBri(getPosBri(e));
                if (i >= 0 && keyframesBri.length > 2) { keyframesBri.splice(i, 1); drawBri(); updateBri(); }
            };
        }

        function getPosBri(e) { const r = canvasBri.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
        function findKFBri(p) {
            const w = canvasBri.offsetWidth, h = canvasBri.offsetHeight;
            const minB = getVal('minBri'), maxB = 100;
            const lat = getVal('latitudeBri');
            const sunTimes = lat ? getSunTimes(lat) : null;
            for (let i = 0; i < keyframesBri.length; i++) {
                const t = sunTimes ? resolveKeyframeTime(keyframesBri[i], sunTimes) : (keyframesBri[i].t || 0);
                const actualBri = (minB + keyframesBri[i].v * (maxB - minB)) / 100;
                const kx = t / 24 * w, ky = vToYBri(actualBri, h);
                if (Math.hypot(kx - p.x, ky - p.y) < 10) return i;
            }
            return -1;
        }

        function getEffectiveKeyframesBri() {
            if (keyframesBri.length < 2) return keyframesBri;
            const lat = getVal('latitudeBri');
            const sunTimes = lat ? getSunTimes(lat) : null;
            const resolved = keyframesBri.map(kf => ({
                t: sunTimes ? resolveKeyframeTime(kf, sunTimes) : (kf.t || 0),
                v: kf.v
            }));
            const first = resolved[0];
            const last = resolved[resolved.length - 1];
            resolved.unshift({ t: last.t - 24, v: last.v });
            resolved.push({ t: first.t + 24, v: first.v });
            return resolved;
        }

        // ä½¿ç”¨ sigmoid å åŠ æ–¹å¼æ’å€¼ï¼ˆä¸å…¬å¼ä¸€è‡´ï¼‰
        function interpolateBri(t) {
            if (keyframesBri.length < 2) return 0.5;
            const kf = getEffectiveKeyframesBri();
            const k = getVal('steepnessBri');

            // èµ·å§‹å€¼
            let value = kf[0].v;

            // å åŠ æ¯ä¸ªè¿‡æ¸¡çš„ sigmoid
            for (let i = 0; i < kf.length - 1; i++) {
                const t1 = kf[i].t;
                const t2 = kf[i + 1].t;
                const delta = kf[i + 1].v - kf[i].v;
                if (delta !== 0) {
                    const mid = (t1 + t2) / 2;
                    const width = Math.max(0.001, (t2 - t1) / 2);
                    const x = k * (t - mid) / width;
                    value += delta * sigmoid(x);
                }
            }
            return Math.max(0, Math.min(1, value));
        }

        // äº®åº¦ Y è½´å›ºå®š 0-100
        function vToYBri(v, h) { return h * (1 - v); }

        function drawBri() {
            if (!ctxBri) return;
            const w = canvasBri.offsetWidth, h = canvasBri.offsetHeight, lat = getVal('latitudeBri');
            const minB = getVal('minBri'), maxB = 100;
            const dark = document.documentElement.classList.contains('dark');
            ctxBri.clearRect(0, 0, w, h);

            // ç½‘æ ¼
            ctxBri.strokeStyle = dark ? '#374151' : '#e5e7eb';
            ctxBri.lineWidth = 1;
            for (let i = 0; i <= 24; i += 6) {
                const x = i / 24 * w;
                ctxBri.beginPath(); ctxBri.moveTo(x, 0); ctxBri.lineTo(x, h); ctxBri.stroke();
                ctxBri.fillStyle = '#9ca3af'; ctxBri.font = '10px sans-serif';
                ctxBri.fillText(`${i}:00`, x + 2, h - 4);
            }

            // Yè½´ç½‘æ ¼çº¿ï¼ˆæŒ‰20%é—´éš”ï¼‰
            ctxBri.setLineDash([]);
            for (let pct = 0; pct <= 100; pct += 20) {
                const y = vToYBri(pct / 100, h);
                ctxBri.beginPath(); ctxBri.moveTo(0, y); ctxBri.lineTo(w, y); ctxBri.stroke();
                ctxBri.fillStyle = '#9ca3af'; ctxBri.font = '10px sans-serif';
                ctxBri.fillText(`${pct}%`, 4, y - 4);
            }

            // æœ€ä½äº®åº¦å‚è€ƒçº¿
            ctxBri.strokeStyle = dark ? '#9ca3af' : '#6b7280';
            ctxBri.setLineDash([4, 4]);
            const yMinBri = vToYBri((minB - 0) / (100 - 0), h);
            ctxBri.beginPath(); ctxBri.moveTo(0, yMinBri); ctxBri.lineTo(w, yMinBri); ctxBri.stroke();
            ctxBri.fillStyle = dark ? '#d1d5db' : '#4b5563';
            ctxBri.fillText(`â† ${minB}% (æœ€ä½)`, w - 80, yMinBri + 12);
            ctxBri.setLineDash([]);

            // æ—¥å‡ºæ—¥è½çº¿å’Œæ›™æš®å…‰
            if (lat) {
                const times = getSunTimes(lat);
                const sun = times.sun;
                const civil = times.civil;
                document.getElementById('sunriseBri').textContent = sun ? fmt(sun.rise) : '--:--';
                document.getElementById('sunsetBri').textContent = sun ? fmt(sun.set) : '--:--';
                document.getElementById('civilDawnBri').textContent = civil ? fmt(civil.rise) : '--:--';
                document.getElementById('civilDuskBri').textContent = civil ? fmt(civil.set) : '--:--';

                // ç»˜åˆ¶æ›™æš®å…‰çº¿ï¼ˆæ·¡è‰²ï¼‰
                if (civil) {
                    ctxBri.strokeStyle = '#fbbf24'; ctxBri.setLineDash([2, 4]);
                    [civil.rise, civil.set].forEach(t => {
                        const x = t / 24 * w;
                        ctxBri.beginPath(); ctxBri.moveTo(x, 0); ctxBri.lineTo(x, h); ctxBri.stroke();
                    });
                }
                // ç»˜åˆ¶æ—¥å‡ºæ—¥è½çº¿
                if (sun) {
                    ctxBri.strokeStyle = '#f59e0b'; ctxBri.setLineDash([4, 4]);
                    [sun.rise, sun.set].forEach(t => {
                        const x = t / 24 * w;
                        ctxBri.beginPath(); ctxBri.moveTo(x, 0); ctxBri.lineTo(x, h); ctxBri.stroke();
                    });
                }
                ctxBri.setLineDash([]);
            } else {
                document.getElementById('sunriseBri').textContent = '--:--';
                document.getElementById('sunsetBri').textContent = '--:--';
                document.getElementById('civilDawnBri').textContent = '--:--';
                document.getElementById('civilDuskBri').textContent = '--:--';
            }

            // æ›²çº¿
            ctxBri.strokeStyle = '#10b981'; ctxBri.lineWidth = 2;
            ctxBri.beginPath();
            for (let t = 0; t <= 24; t += 0.05) {
                // å°†å½’ä¸€åŒ–å€¼è½¬æ¢ä¸ºå®é™…äº®åº¦ç™¾åˆ†æ¯”
                const actualBri = (minB + interpolateBri(t) * (maxB - minB)) / 100;
                const x = t / 24 * w, y = vToYBri(actualBri, h);
                t === 0 ? ctxBri.moveTo(x, y) : ctxBri.lineTo(x, y);
            }
            ctxBri.stroke();

            // å…³é”®å¸§ç‚¹
            const sunTimesBri = lat ? getSunTimes(lat) : null;
            keyframesBri.forEach((kf, i) => {
                const t = sunTimesBri ? resolveKeyframeTime(kf, sunTimesBri) : (kf.t || 0);
                ctxBri.beginPath();
                const actualBri = (minB + kf.v * (maxB - minB)) / 100;
                ctxBri.arc(t / 24 * w, vToYBri(actualBri, h), 7, 0, Math.PI * 2);
                ctxBri.fillStyle = i === draggingBri ? '#ef4444' : getKeyframeColor(kf.type || 'fixed');
                ctxBri.fill();
                ctxBri.strokeStyle = '#fff'; ctxBri.lineWidth = 2; ctxBri.stroke();
            });
        }

        function updateBri() {
            const minB = getVal('minBri'), maxB = 100;
            const lat = getVal('latitudeBri');
            const sunTimes = lat ? getSunTimes(lat) : null;
            const list = document.getElementById('keyframeListBri');
            list.innerHTML = keyframesBri.map((kf, i) => {
                const bri = Math.round(minB + kf.v * (maxB - minB));
                const type = kf.type || 'fixed';
                const resolvedTime = sunTimes ? resolveKeyframeTime(kf, sunTimes) : (kf.t || 0);
                const hr = Math.floor(type === 'fixed' ? (kf.t || 0) : resolvedTime);
                const m = Math.floor((type === 'fixed' ? (kf.t || 0) : resolvedTime) % 1 * 60);
                const offsetH = Math.floor(Math.abs(kf.offset || 0));
                const offsetM = Math.round((Math.abs(kf.offset || 0) % 1) * 60);
                const offsetSign = (kf.offset || 0) >= 0 ? '+' : '-';

                return `<div class="flex items-center gap-2 text-xs py-1.5 px-2 bg-gray-50 dark:bg-neutral-900 rounded">
                    <select onchange="updateKFBri(${i},'type',this.value)" class="px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white" style="font-size:10px">
                        <option value="fixed" ${type === 'fixed' ? 'selected' : ''}>å›ºå®š</option>
                        <option value="sunrise" ${type === 'sunrise' ? 'selected' : ''}>æ—¥å‡º</option>
                        <option value="sunset" ${type === 'sunset' ? 'selected' : ''}>æ—¥è½</option>
                        <option value="civil_dawn" ${type === 'civil_dawn' ? 'selected' : ''}>æ›™å…‰</option>
                        <option value="civil_dusk" ${type === 'civil_dusk' ? 'selected' : ''}>æš®å…‰</option>
                    </select>
                    ${type === 'fixed' ? `
                        <input type="number" value="${hr}" min="0" max="23" onchange="updateKFBri(${i},'h',this.value)" class="w-12 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                        <span class="text-gray-400">:</span>
                        <input type="number" value="${m}" min="0" max="59" step="5" onchange="updateKFBri(${i},'m',this.value)" class="w-12 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                    ` : `
                        <select onchange="updateKFBri(${i},'offsetSign',this.value)" class="w-8 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                            <option value="+" ${offsetSign === '+' ? 'selected' : ''}>+</option>
                            <option value="-" ${offsetSign === '-' ? 'selected' : ''}>-</option>
                        </select>
                        <input type="number" value="${offsetH}" min="0" max="5" onchange="updateKFBri(${i},'offsetH',this.value)" class="w-10 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                        <span class="text-gray-400">h</span>
                        <input type="number" value="${offsetM}" min="0" max="59" step="5" onchange="updateKFBri(${i},'offsetM',this.value)" class="w-10 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                        <span class="text-gray-400">m</span>
                        <span class="text-gray-400" style="font-size:9px">(${fmt(resolvedTime)})</span>
                    `}
                    <span class="text-gray-400 mx-1">â†’</span>
                    <input type="number" value="${bri}" min="${minB}" max="${maxB}" step="5" onchange="updateKFBri(${i},'bri',this.value)" class="w-16 px-1 py-0.5 border border-gray-200 dark:border-neutral-700 rounded text-center dark:bg-neutral-800 dark:text-white">
                    <span class="text-gray-500">%</span>
                    ${keyframesBri.length > 2 ? `<button onclick="deleteKFBri(${i})" class="ml-auto text-red-500 hover:text-red-700">Ã—</button>` : ''}
                </div>`;
            }).join('');
            generateFormulaBri();
        }

        function updateKFBri(i, field, val) {
            const minB = getVal('minBri'), maxB = 100;
            const kf = keyframesBri[i];
            if (field === 'type') {
                kf.type = val;
                if (val === 'fixed') {
                    kf.t = kf.t || 12;
                    delete kf.offset;
                } else {
                    kf.offset = kf.offset || 0;
                    delete kf.t;
                }
            } else if (field === 'h') {
                const m = ((kf.t || 0) % 1) * 60;
                kf.t = Math.max(0, Math.min(24, parseInt(val) + m / 60));
            } else if (field === 'm') {
                const hr = Math.floor(kf.t || 0);
                kf.t = Math.max(0, Math.min(24, hr + parseInt(val) / 60));
            } else if (field === 'offsetSign') {
                kf.offset = (val === '+' ? 1 : -1) * Math.abs(kf.offset || 0);
            } else if (field === 'offsetH') {
                const sign = (kf.offset || 0) >= 0 ? 1 : -1;
                const m = (Math.abs(kf.offset || 0) % 1) * 60;
                kf.offset = sign * (parseInt(val) + m / 60);
            } else if (field === 'offsetM') {
                const sign = (kf.offset || 0) >= 0 ? 1 : -1;
                const hr = Math.floor(Math.abs(kf.offset || 0));
                kf.offset = sign * (hr + parseInt(val) / 60);
            } else if (field === 'bri') {
                kf.v = (parseInt(val) - minB) / (maxB - minB);
            }
            const lat = getVal('latitudeBri');
            const sunTimes = lat ? getSunTimes(lat) : null;
            keyframesBri.sort((a, b) => {
                const ta = sunTimes ? resolveKeyframeTime(a, sunTimes) : (a.t || 0);
                const tb = sunTimes ? resolveKeyframeTime(b, sunTimes) : (b.t || 0);
                return ta - tb;
            });
            drawBri(); updateBri();
        }

        function deleteKFBri(i) {
            if (keyframesBri.length > 2) { keyframesBri.splice(i, 1); drawBri(); updateBri(); }
        }

        function addKeyframeBri() {
            keyframesBri.push({ type: 'fixed', t: 12, v: 0.5 });
            const lat = getVal('latitudeBri');
            const sunTimes = lat ? getSunTimes(lat) : null;
            keyframesBri.sort((a, b) => {
                const ta = sunTimes ? resolveKeyframeTime(a, sunTimes) : (a.t || 0);
                const tb = sunTimes ? resolveKeyframeTime(b, sunTimes) : (b.t || 0);
                return ta - tb;
            });
            drawBri(); updateBri();
        }

        function resetKeyframesBri() {
            const lat = getVal('latitudeBri');
            if (lat) {
                const times = getSunTimes(lat);
                const sun = times.sun;
                const civil = times.civil;
                if (sun && civil) {
                    keyframesBri = [
                        { type: 'fixed', t: 0, v: 0 },
                        { type: 'civil_dawn', offset: 0, v: 0 },
                        { type: 'sunrise', offset: 0, v: 1 },
                        { type: 'sunset', offset: 0, v: 1 },
                        { type: 'civil_dusk', offset: 0, v: 0 },
                        { type: 'fixed', t: 24, v: 0 }
                    ];
                } else if (sun) {
                    keyframesBri = [
                        { type: 'fixed', t: 0, v: 0 },
                        { type: 'sunrise', offset: 0, v: 0 },
                        { type: 'sunrise', offset: 1, v: 1 },
                        { type: 'sunset', offset: -1, v: 1 },
                        { type: 'sunset', offset: 0, v: 0 },
                        { type: 'fixed', t: 24, v: 0 }
                    ];
                } else {
                    keyframesBri = [{ type: 'fixed', t: 0, v: 0.5 }, { type: 'fixed', t: 12, v: 0.5 }];
                }
            } else {
                keyframesBri = [{ type: 'fixed', t: 0, v: 0 }, { type: 'fixed', t: 12, v: 1 }];
            }
            drawBri(); updateBri();
        }

        // ç”Ÿæˆäº®åº¦å…¬å¼ï¼ˆä½¿ç”¨ sigmoid å åŠ ï¼Œæ— æ¯”è¾ƒç¬¦å·ï¼‰
        function generateFormulaBri() {
            const lat = getVal('latitudeBri'), k = getVal('steepnessBri');
            const minB = getVal('minBri'), maxB = 100;
            if (!lat || keyframesBri.length < 2) {
                document.getElementById('formulaBri').textContent = 'è¯·è¾“å…¥çº¬åº¦å¹¶ç¡®ä¿è‡³å°‘æœ‰2ä¸ªå…³é”®å¸§';
                document.getElementById('formulaLenBri').textContent = '';
                document.getElementById('formulaMathBri').textContent = '';
                return;
            }

            // è§£æå…³é”®å¸§æ—¶é—´ï¼ˆç”¨äºé¢„è§ˆå’Œæ•°å­¦è¡¨è¾¾å¼ï¼‰
            const sunTimes = getSunTimes(lat);
            const resolved = keyframesBri.map(kf => ({
                t: resolveKeyframeTime(kf, sunTimes),
                v: kf.v
            })).sort((a, b) => a.t - b.t);

            // æ’åºåçš„åŸå§‹å…³é”®å¸§ï¼ˆç”¨äºç”ŸæˆåŠ¨æ€å…¬å¼ï¼‰
            const sortedKf = [...keyframesBri].sort((a, b) => {
                const ta = resolveKeyframeTime(a, sunTimes);
                const tb = resolveKeyframeTime(b, sunTimes);
                return ta - tb;
            });

            const time = '(hours()*3600+minutes()*60+seconds())';

            const v0 = Math.round(minB + resolved[0].v * (maxB - minB));
            const parts = [`${v0}`];
            const mathParts = [`${v0}`];

            for (let i = 0; i < resolved.length - 1; i++) {
                const t1Expr = getTimeExpression(sortedKf[i], lat);
                const t2Expr = getTimeExpression(sortedKf[i + 1], lat);
                const t1 = Math.round(resolved[i].t * 3600);
                const t2 = Math.round(resolved[i + 1].t * 3600);
                const v1 = Math.round(minB + resolved[i].v * (maxB - minB));
                const v2 = Math.round(minB + resolved[i + 1].v * (maxB - minB));
                const midExpr = typeof t1Expr === 'number' && typeof t2Expr === 'number'
                    ? Math.round((t1Expr + t2Expr) / 2)
                    : `((${t1Expr}+${t2Expr})/2)`;
                const widthExpr = typeof t1Expr === 'number' && typeof t2Expr === 'number'
                    ? Math.max(1, Math.round((t2Expr - t1Expr) / 2))
                    : `((${t2Expr}-${t1Expr})/2)`;
                const delta = v2 - v1;

                if (delta !== 0) {
                    parts.push(`${delta}/(1+pow(e(),-${k}*(${time}-${midExpr})/${widthExpr}))`);
                    mathParts.push(`${delta} Ã— Ïƒ(${k}Ã—(t-${fmt(t1 / 3600 + (t2 - t1) / 7200)})/${Math.round((t2 - t1) / 120)}min)`);
                }
            }

            const formula = `floor(${parts.join('+')})`;
            document.getElementById('formulaBri').textContent = formula;
            document.getElementById('formulaLenBri').textContent = `å…¬å¼é•¿åº¦: ${formula.length} å­—ç¬¦`;
            document.getElementById('formulaMathBri').innerHTML = `<b>æ•°å­¦å½¢å¼:</b> floor(${mathParts.join(' + ')})`;
        }

        function copyFormulaBri() {
            const f = document.getElementById('formulaBri').textContent;
            if (f && !f.includes('è¯·')) navigator.clipboard.writeText(f).then(() => alert('å·²å¤åˆ¶'));
        }
    </script>
</body>

</html>